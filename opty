#!/usr/bin/env python
"""opty

Usage:
    opty [-s SESSIONS] [-d DESIRES] [-r ROOMS] [-t TIMESLOTS] [-i ITERATIONS]

Options:
    -s SESSIONS, --sessions SESSIONS
                        path to a yaml file containing a mapping of
                        session names to a list of speaker
                        [default: sessions.yaml]
    -d DESIRES, --desires DESIRES
                        path to a yaml file containing a mapping of
                        users and their desired sessions (ordered
                        by interest, most interesting first)
                        [default: desires.yaml]
    -r ROOMS, --rooms ROOMS
                        path to a yaml file containing room definitions
                        [default: rooms.yaml]
    -t TIMESLOTS, --time-slots TIMESLOTS
                        path to a yaml file containing time slots 
                        informations
                        [default: timeslots.yaml]
    -i ITERATIONS, --iterations ITERATIONS
                        Number of iterations to guess a good solution
                        [default: 100000]
"""

#TODO accept more than one speaker

from docopt import docopt
from collections import defaultdict
import yaml
import functools
# from solvers.random_solver import RandomSolver
from solvers import get_solver_by_name

def load(filename):
    with open(filename) as fh:
        return yaml.load(fh)


def getRank(solution, desires):
    points = 0
    # it does not seem to be faster this way :P
    # pointlist = [8,7,6,5,4,3,2,1] + [1]*100
    for user, sessions in desires.items():
        blocked_timeslots = []
        for session, point in zip(sessions, #pointlist 
            [8,7,6,5,4,3,2,1] + [1]*max(0,len(sessions)-8) # points for sessions even if you have more than 8
        ):
            slot, room = solution[session]
            if slot not in blocked_timeslots:
                blocked_timeslots.append(slot)
                points += point   

    return points

def printTimetable(solution):
    timeslots = defaultdict(list)
    for session, (timeslot, room) in solution.items():
        timeslots[timeslot].append((room, session))
    for timeslot in sorted(timeslots.keys()):
        print("%s:" % timeslot)
        for room, session in sorted(timeslots[timeslot]):
            print("   %s: %s" % (room, session))
        print("")

def main(args):
    sessions = load(args["--sessions"])
    desires = load(args["--desires"])
    rooms = load(args["--rooms"])
    timeslots = load(args["--time-slots"])
    #use simulated annealing
    #https://en.wikipedia.org/wiki/Simulated_annealing
    # possibly not usefull

    cmp_func = functools.partial(getRank, desires=desires)

    solver = get_solver_by_name("random")(cmp_func)
    best_solution = solver.solve(sessions, rooms, timeslots, args=args)
    printTimetable(best_solution)


if __name__ == "__main__":
    args = docopt(__doc__, version="opty-0.1")
    print(args)
    main(args)